原文标题：Asynchronous Programs with Prioritized Task-Buffers

原文链接： https://dl.acm.org/doi/pdf/10.1145/2393596.2393652

## 具有优先任务缓冲区的异步编程

#### 摘 要

我们认为异步软件系统的算法分析是构建可靠软件的一种手段。设计这种分析的一个关键挑战是确定一个并发模型，该模型不会在实际系统中引入不可行的行为，不会在实际系统中排除实际可行的行为，并将具有挑战性的特性隔离出来，以便集中分析。

在现有的异步软件的指导下，我们提出了一种并发模型，该模型通过任务优先级和多任务缓冲区丰富了现有的串行任务-缓冲区异步模型[29]。我们的模型允许非串行执行：具有高优先级的任务抢占低优先级的任务，并且从不同缓冲区提取的任务可以自由地交错执行。对这些特性进行建模使得分析算法能够检测出异步程序中由于缓冲区间交错和任务中断而导致的未被捕获的编程错误，同时正确忽略由于违反优先级顺序的不可行的执行而导致的假错误。

除了更精确地对现实世界的系统进行建模之外，我们的并发模型还启发出了一种新型分析算法的设计。给定参数 $ K_1, K_2 \in N^2 $ 限制缓冲区间任务交错和缓冲区内任务重排序，我们给出了将代码变为串行代码的代码转换方式，通过这种方式我们可以通过现成的程序分析工具对代码进行分析。对于任何给定的参数值，我们得到的串行程序能够编码所有可能行为的一个子集，并且在两个参数都接近无穷大的情况下，得到的串行程序能够编码所有可能的行为。我们通过对一个原型实现进行实验来证明我们的技术的可行性。我们的原型可以与最先进的并发程序验证工具相媲美，并且能够在简化的Windows设备驱动程序代码中正确识别错误，同时忽略不可行的执行。

**范畴和学科描述**：D.2.4 软件工程：软件/编程的验证   D.2.5 软件工程：测试和调试

**通用术语**： 算法，可靠性，测试，验证

**关键词**： 并行，异步编程，串行化

#### 1. 引 言

交互式计算机系统的用户希望应用程序对用户操作的反应时延尽可能短。例如，当与图形用户界面（GUI）交互时，尽管应用程序可能正在执行长时间的计算，但用户每次单击鼠标和击键都希望得到即时反应。类似地，用户会期望 web 服务器立即回复每个HTTP请求，尽管服务器可能正在处理数千个并发请求。为了确保这种低延迟行为，运行这些应用程序的现代操作系统提供了中断和对应用程序顺序控制流进行并行化的机制。硬件事件初始化中断服务例程，该例程将中断当前执行进程，例如，确保每个按键输入都会立即传达给应用程序。在多处理器系统中，逻辑上不相关的任务是并行执行的，例如将不同的HTTP连接的处理任务划分到几个核或处理器上。

传统的这种响应式软件系统被设计为共享内存的多线程程序：一组软件线程（每个线程本质上都表现为一个递归的顺序程序）并发执行，交错地对共享内存进行读写访问。虽然状态简单，但这种并发模型对于必须通过添加同步（如原子锁定指令）来预测和防止不希望的线程交互的程序员来说是复杂的。在考虑到过度同步（例如，通过单个全局锁保护所有事务）会阻碍交互性并破坏并行化的机会时，这项工作尤其困难。此外，由于底层运行时系统的性能通常很大程度上取决于系统范围内并发线程的数量，因此程序员还必须考虑外部因素，例如运行时平台和其他并发执行程序的存在。

针对多线程的缺点，响应式软件系统的程序员越来越多地采用基于串行任务缓冲区的“异步编程”范式。从本质上讲，程序员将总的计算任务划分为短期运行到完成的任务，这可能会创建额外的任务来异步执行。每个任务在创建时都被放入任务缓冲区中，并且运行时系统确保来自同一缓冲区的任务是可顺序执行的。近年来，桌面应用程序、服务器和嵌入式系统都广泛采用了这种范式。现代web浏览器的 Javascript 引擎[12]，MacOS 和 iOS 中的 Grand Central Dispatch [2]， Linux 的工作队列[30]，. NET 中的异步[22]，以及 Windows 内核中的延迟过程调用[23]都是基于异步编程。即使在单处理的配置（即没有任何并行性）中，像 Node.js[7] 这样的异步框架也被广泛用于设计极具可伸缩性的（web）服务器。

尽管任务缓冲区提供了高度抽象，但构建可靠的无差错程序仍然很困难。因为程序员可能需要将长时间运行的任务 t 重组为一系列短时间运行的任务 t1, ..., ti, 在 tj 和 tj+1 之间执行的其他任务可能会干扰 t 所预期的原子计算。此外，跨多个任务缓冲区执行的任务（例如，在多核处理器上）不能保证顺序执行，并且可能干扰共享内存访问。因此，算法形式推理是防止代价高昂的编程错误的可靠措施。

为了设计有效的程序分析，我们提出了一个规范的模型来对现实世界中响应式系统的并发性进行建模。在我们的模型中，每个任务都有一个相关的优先级级别，每个任务从多个任务缓冲区执行后再提交新的任务到多个任务缓冲区。来自每个缓冲区的任务一个接一个地依次执行，并将新任务提交给到从一开始分配给它们的同一个缓冲区，但是不同缓冲区的任务可能会交叉执行。（最初，每个任务缓冲区至少包含一个初始任务。）当一个任务完成时，将从缓冲区中取出一个优先级最高的挂起任务并开始执行。在任何时刻，当任务 t1 提交了更高优先级的任务 t2 时，t1 被挂起以执行 t2。当没有更高优先级的任务剩余时， t1 恢复执行。优先级级别和任务缓冲区的数量是有限的，并且是静态确定的。此外，从一个任务缓冲区取出的任务可能不会将任务提交到另一个任务缓冲区；唯一的缓冲区间通信是通过共享内存进行的。

我们的模型扩展了 Sen 和 Viswanathan [29] 的单任务缓冲区模型，以更准确地对现实世界中响应式异步程序的并发性进行建模 [2,22,23,30]。在不考虑优先级的情况下，以前的模型保证在实际系统中永远不会出现的打破优先级顺序的执行。通过考虑单个任务缓冲区，前人的模型排除了实际系统中可能出现的不同缓冲区间任务的交错执行。但在形式验证的情况下，前者会导致错误地检测到错误，而后者导致存在未捕获到的错误。

虽然典型的程序分析问题对于没有 [11,29] 甚至有任务优先级 [3] 的单任务缓冲区模型来说是可确定的，但正交扩展到多个交错的任务缓冲区会使一个问题无法确定：递归多线程程序 [28] 足够容易被建模。尽管如此，我们认为多任务缓冲区异步模型非常重要，足以与多线程模型区分开来，原因有二。首先，将具有多个优先级任务缓冲区的异步程序编码为多线程程序需要添加额外的状态和同步机制，以确保（a）相同缓冲区的任务不会交错执行，（b）每个缓冲区中只有最高优先级的任务可以执行。使用通用同步机制对这些约束进行编码忽略了更具声明性的程序结构，并导致低效的程序探索（如我们的实验所示）。其次，通过利用实际程序中并发性的内涵结构，我们可以为优先级程序探索获得有用的启发式方法。例如，在上下文边界的前提下 [24,26] ，我们通过探索相对较少的任务缓冲区间交替执行或相对较少的缓冲区内任务重排序（不直接限制执行的任务数量）的程序执行而受益。

本着开发异步程序结构的精神，我们将参数化程序分析简化为顺序程序分析。分析中参数 K1 和 K2 分别限制了不同缓冲区任务间的交错执行次数（K1）和同一缓冲区任务间的重排序次数（K2）。当我们增加 K1（或 K2 ），我们的分析探索了越来越多的缓冲区间任务交错执行（或越来越多的缓冲区内任务重排序）的情况；当 K1 和 K2 都趋近于无穷时，我们的编码模拟了所有可能有效的执行。对于任何给定的参数值，我们简洁地将一组有限的异步执行编码为非确定性顺序程序进行执行，改非确定性的顺序程序具有多项式数目（使用 K1 和 K2 表示）的共享变量附加副本。我们的编码是按照现有的顺序程序缩减的原则进行组合的 [4,8,15,18] ，因为每个任务缓冲区的执行都是在与其他任务缓冲区隔离的情况下进行的，并且任务缓冲区本身没有显式表示。这样的组合性避免了通过保持其他缓冲区任务的本地状态，甚至通过显式表示单个任务缓冲区的内容而产生的组合爆炸。

规约分两步进行。首先，我们将具有多个任务缓冲区的异步程序规约为具有单个任务缓冲区的异步程序，同时保留任务优先级（第4节）。我们通过引入了共享变量的 K1 份拷贝的代码到代码转换方式来实现这一点。每个副本存储一份任务在被其他缓冲区的任务抢占后恢复的值；这些值最初是估计出来的，随后被验证的。因此，通过切换到下一个共享变量副本，可以在本地模拟与其他任务缓冲区的交错。在第二步（第5节）中，我们将具有任务优先级的单缓冲区异步程序规约为顺序程序。我们再次通过代码到代码的转换来实现这一点。在这种转换中，我们仍然为每个优先级级别引入了共享变量的副本。由于我们的转换的目标是顺序程序，而没有显式表示任务缓冲区，因此每个异步任务提交都被粗略地翻译为同步过程调用。由于低优先级任务的任务提交不允许立即执行，因此我们使用额外的共享变量副本来汇总它们的执行，将它们的执行效果推迟到之后。

本文的贡献如下:

+ 受我们对现实世界中的桌面、服务器和嵌入式响应式软件系统等相关研究的启发（第2节），我们提出了一个并发模型（第3节），该模型自然而准确地捕获了对并发行为进行建模。

+ 我们提出了一种增量程序分析技术，通过两步规约可以转化为顺序程序分析（第4节 和 第5节）。

+ 我们证明了我们的程序分析在实践中相对容易实现并且有效。我们的原型实现能够发现异步C程序中的错误（第6节），也不会不精确地报告现有异步模型的分析有可能检测到的错误，

通过将异步程序转换为顺序程序，我们使得将许多现有的顺序程序分析工具用于（几乎近似的）异步程序分析中。我们使用的转换与程序中存在的数据类型无关，因此能够针对支持任意数据域的分析，例如，布尔程序、带有整数或列表的程序等。

#### 2. 实践中的异步

为了构建实用的验证和调试工具，我们必须指定我们希望建模的并发程序行为。为了更好地理解为什么现有的正式并发编程模型是不够的，我们调研了两个现实世界的应用程序：Windows操作系统中的硬件-软件交互，以及 Apache web 服务器中的异步多处理。

##### 2.1 Windows操作系统中的硬件-软件交互

确保 Windows 内核中高性能硬件交互的主要机制是 优先中断级别。在接下来的讨论中，我们将关注优先级递减顺序的三个级别 DEVICE_LEVEL，DISPATCH_LEVEL 以及 PASSIVE_LEVEL。

在 DEVICE_LEVEL 上，运行软件“中断服务例程”（ISRs）。连接设备到处理器核心的布尔值“中断线”触发固定中断服务例程：当核心的中断线被触发，并且中断服务例程当前没有处于运行状态时，当前运行的代码就会被中断以执行终端服务例程。由于 DEVICE_LEVEL 的中断服务例程阻止执行任何其他代码，包括调度器，因此 DEVICE_LEVEL 的中断服务例程应该在很短的时间内执行，将剩余的计算委托给异步的“延迟过程调用”（DPC）。Windows 内核维护一个挂起的延迟过程调用和Windows 调度器所进行的周期性调用的调用队列，在所有的调用完成前这些调用会在 DISPATCH_LEVEL 上逐个执行，直到队列为空。普通的应用程序运行在 PASSIVE_LEVEL，只在DPC队列为空时才会执行这些应用程序。与 DEVICE_LEVEL 代码一样，PASSIVE_LEVEL 上的延迟过程调用不应该休眠或阻塞等待 I/O；相反，它们应该通过在另一个延迟过程调用队列中等待，或者将工作委托给 PASSIVE_LEVEL 线程来继续推迟未来的工作。尽管延迟过程调用保证不会与同一核心上的其他延迟过程调用或应用程序线程交织，但延迟过程调用可以与中断服务例程、延迟过程调用、Windows 调度程序和其他核心的线程并发执行。

除了带来响应性之外，优先级方案还为设备的共享数据提供同步。由于 PASSIVE_LEVEL 以上的代码是自动执行的，不会被同级或更低级别的代码抢占，因此从 PASSIVE_LEVEL 提升到DISPATCH_LEVEL 也将同步单核上的设备访问。

我们的模型可以精确地模拟 Windows 的这些方面，方式就是通过为每个任务分配三个优先级中的一个，并将来自不同核的代码划分到不同的任务缓冲区。为了模拟硬件和软件之间任意交叉运行的交互，我们可以为单个旋转硬件模拟任务指定一个单独的任务缓冲区。请注意，忽略优先级可能会在使用基于级别的同步保护的设备数据上导致错误的数据竞争错误，而忽略多个缓冲区将会由于在不同的核（或硬件）之间交错运行而错过真正的错误。

##### 2.2 Apache 中通过大中央调度的多处理

在最近发布的软件补丁中，曾经多线程的 Apache web 服务器被重新设计为使用 libdispatch 并发框架的异步程序[1]。在更新后的体系结构中，应用程序启动时会创建许多并发执行的连接侦听器对象，每个对象维护一个单独的传入连接请求队列。每个侦听器通过创建一个新的连接对象来处理连接请求，该对象除了存储与给定客户机连接相关的所有数据外，还维护与该连接相关的任务队列。低级别的网络套接字上的客户端活动会触发附加的连接处理任务，这些任务将被放置在队列中。由周期性计时器和服务器响应触发的任务也被放在队列中。重要的是，尽管负责初始化新连接数据的连接侦听任务分布在多个队列中，但操作任何给定连接数据的任务都放在同一个任务队列中。

底层并发管理器称为大中央调度Grand Central Dispatch (GCD)，负责执行来自各个队列的任务。GCD 保证了队列中的每个任务只在前一个任务完成后执行。对于Apache而言，这确保每个连接在任何时刻最多执行一个任务，并允许来自不同连接和连接侦听器的多个任务并发执行。

对于任何有限数量的连接和侦听器，我们的编程模型通过将任务缓冲区关联到每个连接和连接侦听器来准确对可能的执行进行建模。但现有的规范模型是不够的。单缓冲区异步程序无法对连接之间和连接侦听器之间可能不安全的交错进行建模；在不添加额外同步机制的情况下，多线程机制会使得同一连接的任务错误地交错访问它们的共享内存。

##### 2.3 对任务缓冲区顺序的抽象

这些系统很好地符合我们的编程模型，但有一点需要注意：虽然它们的任务缓冲区可能是 FIFO 顺序的，但我们抽象出来的顺序是假设任务可以以任何顺序从缓冲区中被取出来。我们认为这有两个理由。首先，关于进程访问无界有序队列的算法形式推理仍然是一个难题；其次，我们对这些特定系统的理解使我们相信，虽然 FIFO 语义对于确保公平性和反应性很重要，但关键的安全属性可能不依赖于顺序。当然，这不是一个技术限制——如果需要，可以使用共享内存同步对 FIFO 顺序进行编码（但代价是引入显著的复杂性）。

#### 3. 异步编程

我们考虑一个编程模型，在该模型中计算被划分为多个任务。每个任务都有固定的优先级和与之相关联的任务缓冲区，其行为本质上就像一个递归顺序程序。除了访问由所有其他任务共享的全局内存外，每个任务还可以将其他任务提交到其任务缓冲区以供以后执行。来自每个缓冲区的同级任务一个接一个地串行执行，但会被更高级别的任务中断，并与来自不同缓冲区的任务并行执行。我们将当前没有正在执行任务的任务缓冲区称为空闲任务（idle），将缓冲区中尚未执行的任务称为挂起任务（pending），将已执行完成的任务称为完成任务（completed），将即将在另一个任务完成时被选择执行的任务称为分派任务（dispatched）。最初，每个任务缓冲区都是空闲的，并且至少包含一个挂起任务。当缓冲区处于空闲状态或当前执行的任务完成时，将调度优先级最高的待处理任务开始运行。在任何时刻，当任务 t1 提交了一个高优先级的任务 t2 时，t1 被挂起以执行任务 t2——我们说 t1 被 t2 中断；一旦同一缓冲区的所有高优先级任务完成，t1 就恢复执行。

该模型通过增加优先级[3]和多个任务缓冲区，推广了异步程序的经典模型[29]。在这里，只有最高优先级的任务可以被分派，并且来自不同任务缓冲区的任务可以并行执行。尽管我们倾向于保持任务缓冲区与物理实体（如进程、线程、处理器、内核等）相隔离的概念，但第2节描述了在实际异步系统中存在从这些实体到任务缓冲区的特定映射。

我们在我们的模型中采用交错语义：在任何时间点，只有来自单个任务缓冲区的任务可以执行，但是（缓冲区）抢占可以将控制权转移到来自另一个缓冲区的任务。我们用一个叫做zield的特殊程序语句显式地标记了这种控制权转移的机会。此外，为了进一步扩展我们模型的适用性，我们引入了一个类似的控制转移，称为（任务）抢占，它暂停当前任务的执行，并将控制转移到同一缓冲区的另一个同级任务。我们用一个叫做 yield 的特殊程序语句来标记这些转移的机会。为这种控制转移提供明确的说明，可以使模型具有很大的灵活性。我们编写的原子方法（例如，同步操作）只需在使用原子操作部分禁止 yield 和 zield 操作。我们通过禁止 yield 操作（但不禁止 zield 操作）来模拟 DISPATCH_LEVEL 在 Windows 中的延迟过程调用（参见第2节）。此外，通过在访问共享内存的每个语句之前插入 yield，可以简单地对共享内存多线程程序进行建模。

我们的模型假设内存访问具有顺序上的一致性[20]。虽然大多数现代硬件都暴露了较弱的内存一致性语义，但我们的模型仍然有用：首先，在顺序一致的内存上的bug，仍然是在弱内存模型上的bug；其次，我们仍然考虑良好同步程序的所有行为，即没有数据竞争的程序。由于弱内存的语义引入了一组挑战，我们需要考虑处理这种语义对本文提出的工作没有影响。

##### 3.1 程序语法

设 `Procs` 是一组过程名，`Vals` 是一组值，`Exprs` 是一组表达式，$ N,M /in N^2 $ 表示任务缓冲区和优先级级别的数目，或者说，我们用 `N` 表示集合 $$ {n /in N^2: n < N} $$ 图1的语法描述了我们的异步程序语言（具有优先级的任务缓冲区）。我们不指定表达式 e 的具体语法，尽管我们坚持 `Vals` 包含 `true` 和 `false`，并且 `Exprs` 包含 `Vals` 和（空值）选择操作符`*`。

![image-20240406164631937](.\img\Figure1.jpg)

一个多缓冲区（或单缓冲区）的程序是带有（或不带有）` zield`  语句的程序。在一种程序中，如果每次被提交的过程的第一个语句都是 `while * do yield ` ，则该程序被称为可调换顺序的程序（reorderable）。在一种程序中，如果 `yield` 语句会（或不会）出现（包括在传递调用的过程）则该种程序被称为抢占式（非抢占式）的程序。没有 `yield` 和 `zield` 语句的程序称为调度器相关程序。直观地说，调度器相关的程序在顺序语句（例如，使用 `*` 运算符）中同时保证确定性的情况下，仍然具有一定程度的非确定性（会产生不确定性的程序输出），并在任务调度点处的选择上存在一定的不确定性；在可调换顺序的程序中，任何即将被调度的任务（dispatched）都可以立即被再次挂起（pending）。顺序程序是没有`post`、`yield` 和 `zield` 语句的程序。

每个程序 `P` 声明一个共享的 `type-T` 全局变量`g`，以及一个名为`  p1... pi /in Procs*  `的过程序列，每个 `p`都有一个 `type-T` 形参 `l` 和一个由 `$s_p$` 表示的上层语句。程序语句集 `s` 表示为 `Stmts`。此外，每个程序 `P` 声明 `N` 个无参数初始过程，命名为main(0)， main(1)，…， main(N−1)，该函数既不会被提交也不会被调用；对每个任务缓冲区 $n /in N$，我们将假设初始框架 main(n) 最初处于挂起状态。直观地说，`post m p e `语句是对过程p的异步调用，传入参数为e，过程将在优先级m上执行；`yield` 语句将控制转移到相同任务缓冲区的相同优先级的挂起任务，而 `zield` 语句将控制转移到另一个任务缓冲区的任务。`assume e`语句只在e求值为真时才会执行；我们将在后续规约到顺序程序时使用该语句阻塞不希望的执行[18]。

我们所考虑的编程语言很简单，但是非常具有表现力，因为表达式的语法是自由的，并且我们不会因为只考虑单个全局变量或局部变量而失去一般性。本文的补充扩展版本[9]列出了几个语法扩展，这些扩展很容易简化为我们的语法，我们将在后续章节的源到源转化中使用这些语法。此外，可以使用全局共享内存对硬件中断和基于锁的同步进行编码；参见本文的补充扩展版[9]和3.3节。

##### 3.2 编程的语义



##### 3.3 同步建模



#### 4. 单缓冲区规约



#### 5. 顺序化规约





#### 6. 实现与经验

我们已经在一个叫做 ASYNCCHECKER 的工具中实现了我们的序列化技术。它接受一个以断言作为输入的并发程序，该程序是用C编程语言编写的，扩展了用于生成线程的 post 原语。这个原语允许我们轻松地使用例如 pthread 库或 Win32 API 等提供的接口进行并发性建模。用户还可以控制在哪里插入 yield 和 zields；默认的选择是在每次访问共享变量之前插入它们。ASYNCCHECKER 也接受两个整数作为输入，它们表示 zield 的限制（即第4节中使用的界限）和 yield 的限制（即第5节中使用的界限）。它使用这些限制将程序串行化执行，然后在限制中查找断言违规。当它发现一个断言冲突时，它将显示交错执行的错误跟踪。ASYNCCHECKER 具有通过更改限制来针对一种错误而不是另一种错误的独特能力：高 yield 限制针对需要缓冲区间交错的错误，而高 yield 限制针对需要任务间重新排序或抢占的错误。ASYNCCHECKER 使用 CORRAL [19]作为顺序验证器，这是一个基于 smt 的模型检查器。附录A详细介绍了在序列化过程中如何处理断言和生成错误跟踪。我们现在给出的证据表明，尽管 ASYNCCHECKER 使用了一个精心设计的序列化，它仍然是一个实用的工具，能够在三个不同的实验中发现真正的bug。

**第一个实验** 

我们的第一个实验是将 ASYNCCHECKER 与其他更成熟的工具，在查找多线程程序中的错误（使用单个任务缓冲区并且没有优先级）方面进行比较。这表明：（1）虽然ASYNCCHECKER 是一个原型实现，但它在实际程序中已经能够很好地与现有工具媲美；（2）除非程序需要使用这些特性，否则不需要支付使用多个任务缓冲区或优先级的成本。我们比较ASYNCCHECKER 与 POIROT [25] 进行比较，它也是基于一种顺序化技术[17,18]，但它需要线程时间片绑定，在内涵上类似于 ASYNCCHECKER 的 yield 限制。POIROT 也使用 CORRAL 作为底层的顺序验证器。

对于基准测试，我们使用了由真实设备驱动程序组成的 POIROT 回归套件。一些驱动程序存在植入的bug。驱动程序的大小从 500 行到 700 行不等，其中有三个线程执行驱动程序公开的不同中断服务例程。

![](./img/Figure6.png)

结果如图6所示。我们运行 ASYNCCHECKER 时，zield 字段限制为 1，yield字段的限制等于 POIROT 使用的时间片的限制。在每种情况下，POIROT 和 ASYNCCHECKER 的结果（错误或正确）是相同的。与POIROT相比，ASYNCCHECKER 执行得效果相当好。

据我们所知，对于具有多个任务缓冲区或优先级任务的程序，还没有（除了 ASYNCCHECKER 之外的）工具可以分析它们。然而，仍然有一种不使用 ASYNCCHECKER 的替代方法：可以使用共享内存和同步机制对任务缓冲区和优先级级别进行编码，然后在生成的多线程程序上使用 POIROT。我们也实现了这种方法（让我们称它为 SYNCE）。它引入了共享状态去计算每个缓冲区和每个优先级级别上的任务数量。那么，当存在更高优先级的缓冲区非空时，SYNCE 会插入 `assume` 语句以阻止当前的任务运行。

**第二个实验**

![](./img/Figure7.jpg)

考虑图7所示的单缓冲区程序。（我们假设每两个指令之间存在隐含的 `yields` 和 `zields`）程序在 `bar` 中有一个单独的断言，它根据参数 N 检查 x 的值。对于任何正值的 N，都存在一次违反断言的执行。另外，该执行必须在优先级0和1之间交替进行总共 N 次。我们对这个程序使用不同的 N 值运行 ASYNCCHECKER 和 SYNCE。在每种情况下，我们得到两种工具在最佳限制值下查找违反断言执行所花费的时间。

图7中的表格展示了 SYNCE 较差的可扩展性。原因是 ASYNCCHECKER 可以在 `yield` 的限制为1的情况下找到 bug，但是由于 SYNCE 对优先级进行编码，（在 SYNCE 条件下运行的）POIROT 需要一个与 N 成比例的上下文切换开销。这个开销的增加导致在速度上存在指数级别的下降。

![](./img/Figure8.jpg)



下一个示例如图8所示，在该示例中有两个任务缓冲区，其中各自的初始任务分别为 `main1` 和 `main2`。同样，除了在 `bar` 语句中应该执行 `yield free` 外，在每两个指令之间都有隐含的 `yield` 和 `zield`。这个程序需要在每次增加共享变量时在缓冲区之间切换。值得注意的是，在这个示例中不需要缓冲区内生成— ASYNCCHECKER 可以通过将 yield 预算设置为1并只增加字段预算来发现错误来利用这一观察结果。结果表明，尽管ASYNCCHECKER对字段预算具有指数依赖性，但它的可伸缩性比SYNCE好得多。



**讨论**

虽然我们的实验仅限于小程序，但这并不是因为ASYNCCHECKER在可伸缩性上的限制。（事实上，第一个实验已经展示出 ASYNCCHECKER 的性能已经可以与成熟的并发 bug 查找工具相媲美了）真正的原因来自于为静态分析设置实际程序（如设备驱动程序或 Grand Central Dispatch）所需的建模开销。例如，设备驱动程序需要对操作系统同步原语



（包括处理IRQLs和DPC的原语)进行忠实的建模。我们把这个建模练习留给以后的工作。尽管如此，目前的一组实验表明:(1)我们的正式模型可以捕获现实世界的并发模式;(2)我们的分析易于实现，并且比此类异步程序的其他替代方案更好地扩展。



#### 7.相关研究

我们的具有优先级任务缓冲区的异步程序模型的灵感来自于经典的单缓冲区异步编程模型 [11,13,29] 并在此基础上有所拓展，前人的研究中也曾考虑了一次任务优先级 [3]。尽管 Atig 等人 [3] 在具有优先级的异步规划模型中显示了状态可达性的可判定性，但他们的决策过程依赖于 Petri 网中的可达性，而目前已知的 Petri 网算法非常复杂——它们是非原语递归的。我们在此基础上通过（1）增加多个任务缓冲区，（2）展示依赖于任务优先级和或多个任务缓冲区的真实世界示例，以及（3）给出一个相对实用的参数化下逼近的状态可达性算法，随着参数值的增加，通过减少顺序程序中的状态可达性，逐步探索越来越多的程序行为。

我们的工作密切遵循从并发程序到顺序程序的组成规约的研究路线。最初所谓的“序列化” [27] 探索了多线程程序在线程之间至多一个上下文切换，后来该方法被扩展到能够处理以时间片轮转顺序执行的静态确定的线程集之间的参数化上下文切换数量[18]。La Torre 等人 [15] 后来提供了一种更适合于对结果序列程序进行模型检查的替代编码，并最终扩展了该方法，以处理由无限数量的静态确定线程参数化的程序 [16]。不久之后，Emmi 等人 [8] 进一步扩展了这些结果，以处理无限大数量的动态创建任务，这除了适用于多线程程序外，还可以处理异步事件驱动程序 [11,13,29]。Bouajjani等人 [4] 将这些结果进一步推向序列化，试图在给定的分析预算内探索尽可能多的行为。虽然后两种顺序化适用于动态创建无限数量任务的异步程序，但它们不考虑任务优先级和多个任务缓冲区。虽然Kidd等人 [14] 和 Chaki 等人 [6] 都证明了优先级感知的顺序化，但他们的规约假设了固定数量的静态确定任务，并且不考虑多个任务缓冲区。

#### 8. 结论

我们引入了具有多个优先级任务缓冲区的异步程序的规范模型，该模型能够真实地对许多现实世界异步系统中存在的并发性进行建模。虽然我们模型中的程序分析比较复杂，但我们提出了一种通过规约为顺序程序分析的增量近似分析算法。参数 $ K_1, K_2 /in N^2 $的顺序规约限制，或者说，缓冲区间交错运行和缓冲区内任务排序的数量；当K1和K2趋近于无穷时，我们的规约探讨了所有可能的程序行为。我们证明这种还原是相对容易实现的，在 Windows 内核中的异步设备驱动程序代码中，通过使用现成的顺序分析工具能够发现并发错误，而不会报告由于建模不精确而导致的虚假错误。

#### A. 断言和错误跟踪

断言。本文中提出的程序转换保留了可达性事实，它讨论了程序执行的开始和结束状态。为了检查程序中的断言，我们首先将它们映射到如下所示可达性事实：当断言的条件被违反时，程序将被引入一个标志并抛出一个异常。异常会中止当前执行和所有挂起的任务。如果我们看到异常标志在执行的结束状态中被抛出，那么我们就知道在该执行中一定违反了断言。因此，我们的实现断言在我们的技术产生的顺序程序中没有被设置异常标志。

错误跟踪。当顺序验证程序在我们的方式所产生的顺序程序中发现错误时，我们仍然需要将错误映射回原始并发程序的执行。我们遵循一种通用的方法来解决这个问题，这种方法也很容易适应其他顺序化。首先，我们在模型中引入一个名为 `print` 的原语，它接受一个变量作为参数。我们假设，当顺序验证程序找到一个错误跟踪（在顺序程序中）时，它通过某条 `print` 语句，按照它们在跟踪中出现的顺序打印它们的参数值。

另外，我们在原始程序中引入一个名为 `traceCnt` 的额外整数变量，该变量初始化为0。最后，在每个任务的开始以及每个 yield、zield 和 post 语句之后，我们插入代码 `loc:= traceCnt; print(loc); traceCnt ++ `，其中loc是一个新的局部变量。因为 print 语句只对局部状态进行操作，所以序列化过程不会影响到它。当顺序验证程序报告错误跟踪时，只需按照打印值的顺序来重建错误跟踪中的交错运行。

#### 参考文献

略