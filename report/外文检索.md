### 外文文献检索

与 asynchronous 和 IO driver 有关

##### [Application controlled parallel asynchronous IO](https://dl.acm.org/doi/10.1145/1188455.1188639)

Filesystems continue to be a major performance bottleneck for many applications across a variety of hardware architectures. Most existing attempts to address this issue, e.g., PVFS, rely upon system resources which are not typically tuned for any specific user application, whereas others rely on special hardware capabilities such as shared-memory.We have developed an MPI-based parallel asynchronous I/O (PAIO) software package which enables applications to balance compute and I/O resources directly. PAIO uses a queueing mechanism to stage the data, sent over in parallel from compute nodes, on the reserved I/O nodes. Because the bandwidth of the inter-processor network greatly exceeds that of the filesystem, significant performance improvements can be achieved under a bursty I/O load provided sufficient memory is available for the I/O nodes. The results of PAIO for typical weather applications on an SGI Altix and other architectures will be reported in a poster board.

本文设计了一种并行异步IO（PAIO）软件包，使得应用能够直接的平衡计算和IO资源。

Shujia Zhou, Amidu Oloso, Megan Damon, and Tom Clune. 2006. Application controlled parallel asynchronous IO. In Proceedings of the 2006 ACM/IEEE conference on Supercomputing (SC '06). Association for Computing Machinery, New York, NY, USA, 178–es. https://doi.org/10.1145/1188455.1188639



##### [Asynchronous state machine synthesis using data driven clocks](https://dl.acm.org/doi/10.5555/159754.159758)

本文的贡献主要是提出了一种实现异步状态机的方法，使得得到的异步状态机具有最小的状态变量和任意状态编码（a novel and systematic approach to design of asynchronous state machines with minimum state variables and arbitary state encoding）

Farhad Aghadasi. 1992. Asynchronous state machine synthesis using data driven clocks. In Proceedings of the conference on European design automation (EURO-DAC '92). IEEE Computer Society Press, Washington, DC, USA, 9–14.



##### [Synchronous/asynchronous operation](https://dl.acm.org/doi/10.5555/1074100.1074847)

The flow of information within a digital network may be said to be either *synchronous* or *asynchronous*. In the case of synchronous operation, a transfer of data from one point to another is assumed to occur within a fixed time interval known to both the sending and receiving devices. The sender and receiver are synchronized by a signal called the *clock*, which may be supplied externally to both, or generated by the sender with the data, and occasionally incorporated within it, but often sent on a separate signal line. In the case of asynchronous operation, the sending device or circuit need have no knowledge of the time-scale on which the receiver (and intervening connection) operates, but rather transmits its data with a "data ready" signal and then awaits a reply to the signal sent. Upon receipt of the reply by the sender, it removes its original data and status signal from the line, often (but not necessarily) waiting for the removal of the reply by the sender before proceeding with a second transfer.

本文主要介绍了同步和异步操作的机制。(但文章比较短)

Kenneth C. Smith. 2003. Synchronous/asynchronous operation. Encyclopedia of Computer Science. John Wiley and Sons Ltd., GBR, 1735–1737.



##### [Asynchronous programs with prioritized task-buffers](https://dl.acm.org/doi/10.1145/2393596.2393652)

We consider the algorithmic analysis of asynchronous software systems as a means for building reliable software. A key challenge in designing such analyses is identifying a concurrency model which does not extraneously introduce behaviors infeasible in the actual system, does not extraneously exclude actual behaviors, and isolates the challenging features for analyses to focus on.

Guided by real-world asynchronous software, we propose a concurrency model which enriches the existing serial task-buffer asynchrony model [29] with task-priorities and multiple task-buffers. Our model allows non-serial execution: tasks with higher priority preempt lower-priority tasks, and tasks drawn from distinct buffers freely interleave with one another. Modeling these features allows analysis algorithms to detect otherwise uncaught programming errors in asynchronous programs due to inter-buffer interleaving and task-interruption, while correctly ignoring false errors due to infeasible out-of-priority-order executions.

Besides more precisely capturing real-world systems, our concurrency model inspires the design of a novel analysis algorithm. Given parameters *K*1, *K*2 ε N that restrict inter-buffer task interleaving and intra-buffer task reordering, we give a code-to-code translation to sequential programs, which can then be analyzed by off-the-shelf program analysis tools. For any given parameter values, the resulting sequential program encodes a subset of possible behaviors, and in the limit as both parameters approach infinity, the sequential program encodes all behaviors. We demonstrate the viability of our technique by experimenting with a prototype implementation. Our prototype is competitive with state-of-the-art concurrent program verification tools, and is able to correctly identify errors in simplified Windows device driver code, while ignoring infeasible executions.

本文提出了一种并发模型，用任务优先级和多个任务缓冲区丰富了现有的串行任务缓冲区异步模型。

Michael Emmi, Akash Lal, and Shaz Qadeer. 2012. Asynchronous programs with prioritized task-buffers. In Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering (FSE '12). Association for Computing Machinery, New York, NY, USA, Article 48, 1–11. https://doi.org/10.1145/2393596.2393652